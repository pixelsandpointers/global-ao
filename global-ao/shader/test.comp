#version 460 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding=1) buffer ssbo_vertices{
    float vertex_pos[];
};

layout(std430, binding=2) buffer ssbo_vertex_normals{
    float vertex_normal[];
};

layout(std430, binding=3) buffer ssbo_triangles{
    uint triangles[];
};

layout(std430, binding=4) buffer ssbo_aoOutput{
    float aoOutput[];
};

uniform uint num_verts;
uniform uint num_tris;
uniform uint num_samples;

//https://towardsdatascience.com/how-to-generate-a-vector-of-random-numbers-on-a-gpu-a37230f887a6
uint rand_xorshift(inout uint rng_state){    
    rng_state ^= (rng_state << 13);
    rng_state ^= (rng_state >> 17);    
    rng_state ^= (rng_state << 5);    
    return rng_state;
}

uint rand_uint(inout uint rng_state){ 
    return rand_xorshift(rng_state);
}

float rand_float(inout uint rng_state){    
    return float(rand_xorshift(rng_state))/float(4294967295.0f);
}

vec3 spherePoint(inout uint rng_state) {
    for (int i = 0; i < 10; ++i){
        float x = 2.0*rand_float(rng_state)-1.0;
        float y = 2.0*rand_float(rng_state)-1.0;
        float z = 2.0*rand_float(rng_state)-1.0;
        vec3 dir = vec3(x, y, z);
        if (length(dir) < 1.0)
        {
            normalize(dir);
            return dir;
        }
    }
    return vec3(0, 0, 0);
}

bool rayTriangleTest(vec3 origin, vec3 direction, uint index, bool backfaceCulling){
    // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
    const float EPSILON = 0.0000001;
    uvec3 tri = uvec3(triangles[3*index+0], triangles[3*index+1], triangles[3*index+2]);
    vec3 v0 = vec3(vertex_pos[3*tri.x+0], vertex_pos[3*tri.x+1], vertex_pos[3*tri.x+2]);
    vec3 v1 = vec3(vertex_pos[3*tri.y+0], vertex_pos[3*tri.y+1], vertex_pos[3*tri.y+2]);
    vec3 v2 = vec3(vertex_pos[3*tri.z+0], vertex_pos[3*tri.z+1], vertex_pos[3*tri.z+2]);
    vec3 edge1, edge2, h, s, q;
    float a, f, u, v;
    edge1 = v1-v0;
    edge2 = v2-v0;

    if (backfaceCulling){
        vec3 normal = cross(edge1, edge2);
        if (dot(direction, normal) < 0.0) return false;
    }

    h = cross(direction, edge2);
    a = dot(edge1, h);

    if (a > -EPSILON && a < EPSILON)
        return false;    // This ray is parallel to this triangle.

    f = 1.0 / a;
    s = origin - v0;
    u = f * dot(s, h);

    if (u < 0.0 || u > 1.0)
        return false;

    q = cross(s, edge1);
    v = f * dot(direction, q);

    if (v < 0.0 || u + v > 1.0)
        return false;

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);

    if (t > EPSILON) // ray intersection
    {
        return true;
    }
    else // This means that there is a line intersection but not a ray intersection.
        return false;
}

void main(){
    uint rngState = gl_LocalInvocationIndex ^ 1353212;
    rand_xorshift(rngState);
    
    ///*
    uint v_idx = gl_GlobalInvocationID.x;
    vec3 v_pos = vec3(vertex_pos[3*v_idx+0],vertex_pos[3*v_idx+1],vertex_pos[3*v_idx+2]);
    uint sum = 0;
    for(uint s_idx = 0; s_idx < num_samples; ++s_idx){
        vec3 vtx_n = vec3(vertex_normal[3*v_idx+0], vertex_normal[3*v_idx+1], vertex_normal[3*v_idx+2]);
        vec3 hemidir = spherePoint(rngState);
        hemidir = dot(hemidir, vtx_n)<0?-hemidir:hemidir;
        bool hit = false;
        for(uint t_idx = 0; t_idx < num_tris; ++t_idx){
            if(rayTriangleTest(v_pos, hemidir, t_idx, true)){
                hit = true;
                break;
            }
        }
        if (hit) ++sum;
    }
    aoOutput[v_idx] = 1.0 - float(sum)/float(num_samples);
    //*/
}
#version 460 core

layout (local_size_x = 1, local_size_y = 256, local_size_z = 1) in;

layout(std430, binding=1) buffer ssbo_vertices{
    float vertex_pos[];
};

layout(std430, binding=2) buffer ssbo_vertex_normals{
    float vertex_normal[];
};

layout(std430, binding=3) buffer ssbo_triangles{
    uint triangles[];
};

layout(std430, binding=4) buffer ssbo_aoOutput{
    uint aoOutput[];
};

uniform uint num_verts;
uniform uint num_tris;

shared uint triangleHits;

//https://towardsdatascience.com/how-to-generate-a-vector-of-random-numbers-on-a-gpu-a37230f887a6
uint rand_xorshift(inout uint rng_state){    
    rng_state ^= (rng_state << 13);
    rng_state ^= (rng_state >> 17);    
    rng_state ^= (rng_state << 5);    
    return rng_state;
}

uint rand_uint(inout uint rng_state){ 
    return rand_xorshift(rng_state);
}

float rand_float(inout uint rng_state){    
    return float(rand_xorshift(rng_state))/float(4294967295.0f);
}

float rand_gauss(inout uint rng_state){
    //https://stackoverflow.com/a/6178290
    float theta = 2 * 3.1415926 * rand_float(rng_state);
    float rho = sqrt(-2 * log(1 - rand_float(rng_state)));
    return cos(theta) * rho;
}

vec3 spherePointGauss(inout uint rng_state) {
    float x = 2.0*rand_gauss(rng_state)-1.0;
    float y = 2.0*rand_gauss(rng_state)-1.0;
    float z = 2.0*rand_gauss(rng_state)-1.0;
    vec3 dir = vec3(x, y, z);
    normalize(dir);
    return dir;
}

vec3 spherePointCube(inout uint rng_state) {
    for (int i = 0; i < 10; ++i){
        float x = 2.0*rand_float(rng_state)-1.0;
        float y = 2.0*rand_float(rng_state)-1.0;
        float z = 2.0*rand_float(rng_state)-1.0;
        vec3 dir = vec3(x, y, z);
        if (length(dir) < 1.0)
        {
            normalize(dir);
            return dir;
        }
    }
    return vec3(0, 0, 0);
}

vec3 spherePoint(inout uint rng_state) {
    //return spherePointGauss(rng_state);
    return spherePointCube(rng_state);
}

bool rayTriangleTest(vec3 origin, vec3 direction, uint index, bool backfaceCulling){
    // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
    const float EPSILON = 0.0000001;
    uvec3 tri = uvec3(triangles[3*index+0], triangles[3*index+1], triangles[3*index+2]);
    vec3 v0 = vec3(vertex_pos[3*tri.x+0], vertex_pos[3*tri.x+1], vertex_pos[3*tri.x+2]);
    vec3 v1 = vec3(vertex_pos[3*tri.y+0], vertex_pos[3*tri.y+1], vertex_pos[3*tri.y+2]);
    vec3 v2 = vec3(vertex_pos[3*tri.z+0], vertex_pos[3*tri.z+1], vertex_pos[3*tri.z+2]);
    vec3 edge1, edge2, h, s, q;
    float a, f, u, v;
    edge1 = v1-v0;
    edge2 = v2-v0;

    if (backfaceCulling){
        vec3 normal = cross(edge1, edge2);
        if (dot(direction, normal) < 0.0) return false;
    }

    h = cross(direction, edge2);
    a = dot(edge1, h);

    if (a > -EPSILON && a < EPSILON)
        return false;    // This ray is parallel to this triangle.

    f = 1.0 / a;
    s = origin - v0;
    u = f * dot(s, h);

    if (u < 0.0 || u > 1.0)
        return false;

    q = cross(s, edge1);
    v = f * dot(direction, q);

    if (v < 0.0 || u + v > 1.0)
        return false;

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);

    if (t > EPSILON) // ray intersection
    {
        return true;
    }
    else // This means that there is a line intersection but not a ray intersection.
        return false;
}

void main(){
    /*
    Some possible optimizations
    -split linear acces to 2d Workgroups
    -use local workgroups to share samples
    -use local workgroups to split triangle tests
    */
    uint initialOffset = aoOutput[gl_GlobalInvocationID.x];
    uint rngState = ((gl_GlobalInvocationID.x*+516515)*(gl_GlobalInvocationID.y+352216)*(gl_GlobalInvocationID.z+358151)*(initialOffset+1)) ^ 1353212;
    rngState = rand_xorshift(rngState);

    //*
    uint v_idx = gl_GlobalInvocationID.x;
    vec3 v_pos = vec3(vertex_pos[3*v_idx+0],vertex_pos[3*v_idx+1],vertex_pos[3*v_idx+2]);
    
    vec3 vtx_n = vec3(vertex_normal[3*v_idx+0], vertex_normal[3*v_idx+1], vertex_normal[3*v_idx+2]);
    vec3 hemidir = spherePoint(rngState);
    hemidir = dot(hemidir, vtx_n)<0?-hemidir:hemidir;

    for(uint t_idx = 0; t_idx < num_tris; ++t_idx){
        if(rayTriangleTest(v_pos, hemidir, t_idx, true)){
            atomicAdd(triangleHits, 1);
            break;
        }
    }

    if (gl_LocalInvocationID.y == 0) aoOutput[v_idx] += triangleHits;
}
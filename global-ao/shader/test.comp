#version 460 core

layout (local_size_x = 1, local_size_y = 256, local_size_z = 1) in;

layout(std430, binding=1) buffer ssbo_vertices{
    float vertex_pos[];
};

layout(std430, binding=2) buffer ssbo_vertex_normals{
    float vertex_normal[];
};

layout(std430, binding=3) buffer ssbo_triangles{
    uint triangles[];
};

layout(std430, binding=4) buffer ssbo_aoOutput{
    uint aoOutput[];
};

struct RenderNodeCompute
{
    float aabb_min_x;
    float aabb_min_y;
    float aabb_min_z;
    float aabb_max_x;
    float aabb_max_y;
    float aabb_max_z;
    int left;
    int right;
    int startTriOffset;
    int numTri;
};

layout(std430, binding=5) buffer ssbo_render_Nodes_Compute{
    RenderNodeCompute renderNodesCompute[];
};

layout(std430, binding=6) buffer ssbo_perNodeTriIndices{
    uint triIndices[];
};

layout(std430, binding=7) buffer ssbo_debug_random{
    float debug_random[];
};

layout(std430, binding=8) buffer ssbo_num_tri_per_vert{
    uint num_tri_per_vert[];
};

layout(std430, binding=9) buffer ssbo_per_tri_res{
    uint per_tri_res[];
};

layout(std430, binding=10) buffer ssbo_per_tri_idx{
    uint per_tri_idx[];
};

layout(std430, binding=11) buffer ssbo_per_tri_data{
    uint per_tri_data[];
};

layout(std430, binding=12) buffer ssbo_bvh_tree{
    uint bvh_tree[];
};

layout(std430, binding=13) buffer ssbo_sp{
    float sphere_points[];
};

uniform uint num_verts;
uniform uint num_tris;

shared uint triangleHits;

//https://towardsdatascience.com/how-to-generate-a-vector-of-random-numbers-on-a-gpu-a37230f887a6
uint rand_xorshift(inout uint rng_state){    
    rng_state ^= (rng_state << 13);
    rng_state ^= (rng_state >> 17);    
    rng_state ^= (rng_state << 5);    
    return rng_state;
}

uint rand_uint(inout uint rng_state){ 
    return rand_xorshift(rng_state);
}

float rand_float(inout uint rng_state){    
    return float(rand_xorshift(rng_state))/float(4294967295.0f);
}

float rand_gauss(inout uint rng_state){
    //https://stackoverflow.com/a/6178290
    float theta = 2 * 3.1415926 * rand_float(rng_state);
    float rho = sqrt(-2 * log(1 - rand_float(rng_state)));
    return cos(theta) * rho;
}

vec3 spherePointGauss(inout uint rng_state) {
    float x = 2.0*rand_gauss(rng_state)-1.0;
    float y = 2.0*rand_gauss(rng_state)-1.0;
    float z = 2.0*rand_gauss(rng_state)-1.0;
    vec3 dir = vec3(x, y, z);
    dir = normalize(dir);
    return dir;
}

vec3 spherePointCube(inout uint rng_state) {
    for (int i = 0; i < 10; ++i){
        float x = 2.0*rand_float(rng_state)-1.0;
        float y = 2.0*rand_float(rng_state)-1.0;
        float z = 2.0*rand_float(rng_state)-1.0;
        vec3 dir = vec3(x, y, z);
        if (length(dir) < 1.0)
        {
            normalize(dir);
            return dir;
        }
    }
    return vec3(0, 0, 0);
}

vec3 spherePoint(inout uint rng_state) {
    //return spherePointGauss(rng_state);
    return spherePointCube(rng_state);
}

bool rayTriangleTest(vec3 origin, vec3 direction, uint index, bool backfaceCulling){
    // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
    const float EPSILON = 0.0000001;
    uvec3 tri = uvec3(triangles[3*index+0], triangles[3*index+1], triangles[3*index+2]);
    vec3 v0 = vec3(vertex_pos[3*tri.x+0], vertex_pos[3*tri.x+1], vertex_pos[3*tri.x+2]);
    vec3 v1 = vec3(vertex_pos[3*tri.y+0], vertex_pos[3*tri.y+1], vertex_pos[3*tri.y+2]);
    vec3 v2 = vec3(vertex_pos[3*tri.z+0], vertex_pos[3*tri.z+1], vertex_pos[3*tri.z+2]);
    vec3 edge1, edge2, h, s, q;
    float a, f, u, v;
    edge1 = v1-v0;
    edge2 = v2-v0;

    if (backfaceCulling){
        vec3 normal = cross(edge1, edge2);
        if (dot(direction, normal) < 0.0) return false;
    }

    h = cross(direction, edge2);
    a = dot(edge1, h);

    if (a > -EPSILON && a < EPSILON)
        return false;    // This ray is parallel to this triangle.

    f = 1.0 / a;
    s = origin - v0;
    u = f * dot(s, h);

    if (u < 0.0 || u > 1.0)
        return false;

    q = cross(s, edge1);
    v = f * dot(direction, q);

    if (v < 0.0 || u + v > 1.0)
        return false;

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);

    if (t > EPSILON) // ray intersection
    {
        return true;
    }
    else // This means that there is a line intersection but not a ray intersection.
        return false;
}

bool rayAABBTest(float aabb_min_x, float aabb_min_y, float aabb_min_z, float aabb_max_x, float aabb_max_y, float aabb_max_z, vec3 origin, vec3 dir)
{
    // reference https://web.archive.org/web/20090803054252/http://tog.acm.org/resources/GraphicsGems/gems/RayBox.c
    bool inside = true;
	uint quadrant[3];
	int whichPlane;
	float maxT[3];
	float candidatePlane[3];

    const int NUMDIM = 3;
    const int RIGHT = 0;
    const int LEFT = 1;
    const int MIDDLE = 2;

    const bool FALSE = false;
    const bool TRUE = true;

    vec3 minB = vec3(aabb_min_x, aabb_min_y, aabb_min_z);
    vec3 maxB = vec3(aabb_max_x, aabb_max_y, aabb_max_z);

    vec3 coord;

	// Find candidate planes; this loop can be avoided if rays cast all from the eye(assume perpsective view)
	for (int i=0; i<3; i++){
		if(origin[i] < minB[i]) {
			quadrant[i] = LEFT;
			candidatePlane[i] = minB[i];
			inside = FALSE;
		}else if (origin[i] > maxB[i]) {
			quadrant[i] = RIGHT;
			candidatePlane[i] = maxB[i];
			inside = FALSE;
		}else	{
			quadrant[i] = MIDDLE;
        }
    }

	// Ray origin inside bounding box
	if(inside)	{
		coord = origin;
		return (TRUE);
	}

	// Calculate T distances to candidate planes
	for (int i = 0; i < NUMDIM; i++)
		if (quadrant[i] != MIDDLE && dir[i] !=0.)
			maxT[i] = (candidatePlane[i]-origin[i]) / dir[i];
		else
			maxT[i] = -1.;

	// Get largest of the maxT's for final choice of intersection
	whichPlane = 0;
	for (int i = 1; i < NUMDIM; i++)
		if (maxT[whichPlane] < maxT[i])
			whichPlane = i;

	// Check final candidate actually inside box
	if (maxT[whichPlane] < 0.) return (FALSE);
	for (int i = 0; i < NUMDIM; i++)
		if (whichPlane != i) {
			coord[i] = origin[i] + maxT[whichPlane] * dir[i];
			if (coord[i] < minB[i] || coord[i] > maxB[i])
				return (FALSE);
		} else {
			coord[i] = candidatePlane[i];
		}
	return (TRUE);// ray hits box
}

void main(){
    /*
    Some possible optimizations
    -split linear acces to 2d Workgroups
    -use local workgroups to share samples
    -use local workgroups to split triangle tests
    */
    if (gl_LocalInvocationID.y == 0) triangleHits = 0;

    bool useBVH = false;
    uint v_idx = gl_GlobalInvocationID.x;
    uint initialOffset = aoOutput[v_idx];
    uint rngState = ((gl_GlobalInvocationID.x*+516515)*(gl_GlobalInvocationID.y+352216)*(gl_GlobalInvocationID.z+358151)*(initialOffset+1)) ^ 1353212;
    rngState = rand_xorshift(rngState);
    rngState = rand_xorshift(rngState);

    vec3 v_pos = vec3(vertex_pos[3*v_idx+0],vertex_pos[3*v_idx+1],vertex_pos[3*v_idx+2]);
    vec3 vtx_n = vec3(vertex_normal[3*v_idx+0], vertex_normal[3*v_idx+1], vertex_normal[3*v_idx+2]);

    //vec3 hemidir = spherePoint(rngState);
    vec3 hemidir = vec3(sphere_points[3*256*v_idx+3*gl_LocalInvocationID.y+0],
                        sphere_points[3*256*v_idx+3*gl_LocalInvocationID.y+1],
                        sphere_points[3*256*v_idx+3*gl_LocalInvocationID.y+2]);

    if (dot(hemidir, vtx_n)<0.0) hemidir = -hemidir;
    //hemidir = dot(hemidir, vtx_n)<0?-hemidir:hemidir;

    debug_random[3*256*v_idx+3*gl_LocalInvocationID.y+0] = hemidir.x;
    debug_random[3*256*v_idx+3*gl_LocalInvocationID.y+1] = hemidir.y;
    debug_random[3*256*v_idx+3*gl_LocalInvocationID.y+2] = hemidir.z;
    
    if (useBVH){
        uint nodeIdxBuff[1000];
        nodeIdxBuff[0] = 0;
        int currentNodeIdxBuffIdx = 0;
        uint traversals = 0;
        bool hit = false;
        for (int i = 0; i < 1000; ++i){
            bvh_tree[40*v_idx+i] = currentNodeIdxBuffIdx;
            RenderNodeCompute renderNodeCompute = renderNodesCompute[nodeIdxBuff[currentNodeIdxBuffIdx]];
            // test if ray hits AABB
            bool hitBVH = rayAABBTest(renderNodeCompute.aabb_min_x,
            renderNodeCompute.aabb_min_y,
            renderNodeCompute.aabb_min_z,
            renderNodeCompute.aabb_max_x,
            renderNodeCompute.aabb_max_y,
            renderNodeCompute.aabb_max_z,
            v_pos, hemidir);

            // if yes add child nodes
            if (hitBVH) {
                // if it has triangles test them
                if (renderNodeCompute.numTri > 0){
                    for (int t = 0; t < renderNodeCompute.numTri; ++t){
                        num_tri_per_vert[v_idx] = renderNodeCompute.numTri;
                        if(rayTriangleTest(v_pos, hemidir, triIndices[t + renderNodeCompute.startTriOffset], true)){
                            atomicAdd(triangleHits, 1);
                            //++triangleHits;
                            hit = true;
                            per_tri_res[400*v_idx + t] = 1;
                            per_tri_idx[400*v_idx + t] = triIndices[t + renderNodeCompute.startTriOffset];
                            per_tri_data[400*v_idx + 3*t + 0] = triangles[3*triIndices[t + renderNodeCompute.startTriOffset]+0];
                            per_tri_data[400*v_idx + 3*t + 1] = triangles[3*triIndices[t + renderNodeCompute.startTriOffset]+1];
                            per_tri_data[400*v_idx + 3*t + 2] = triangles[3*triIndices[t + renderNodeCompute.startTriOffset]+2];
                            break;
                        }
                    }
                    if (hit) break;
                }
                if (renderNodeCompute.left != -1){
                    nodeIdxBuff[currentNodeIdxBuffIdx] = renderNodeCompute.left;
                    ++currentNodeIdxBuffIdx;
                }
                if (renderNodeCompute.right != -1){
                     nodeIdxBuff[currentNodeIdxBuffIdx] = renderNodeCompute.right;
                     ++currentNodeIdxBuffIdx;
                }
            }
            // if not check next node
            --currentNodeIdxBuffIdx;
            ++traversals;
            if (currentNodeIdxBuffIdx < 0) break;
        }
        if (gl_LocalInvocationID.y == 0) aoOutput[v_idx] = triangleHits;
        //if (gl_LocalInvocationID.y == 0) aoOutput[v_idx] = v_idx;
        //aoOutput[v_idx] += triangleHits;
        //if (gl_LocalInvocationID.y == 0) aoOutput[v_idx] = uint(traversals);
    } else {
        for(uint t_idx = 0; t_idx < num_tris; ++t_idx){
            if(rayTriangleTest(v_pos, hemidir, t_idx, true)){
                atomicAdd(triangleHits, 1);
                break;
            }
        }
        if (gl_LocalInvocationID.y == 0) aoOutput[v_idx] += triangleHits;
    }
}